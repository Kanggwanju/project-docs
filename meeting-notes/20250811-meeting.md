# 📌 2025년 8월 11일 독서 소모임 프로젝트 회의록


각자 맡은 역할의 issue를 올리고, 개발 작업 시작
엔티티 생성, Repository 만들기



## 관계 구조

```
User                Meeting
  |                   |
  | 1              1  |
  |                   |
  +---< MeetingParticipant >---+
            (중간 테이블)
```

* **User ↔ MeetingParticipant** : 1\:N (한 유저가 여러 참가 이력)
* **Meeting ↔ MeetingParticipant** : 1\:N (한 모임에 여러 참가자)

즉,

* User 입장: 내가 참가한 모임 참가 기록이 여러 개 (`meetingParticipants`)
* Meeting 입장: 해당 모임의 참가자 기록이 여러 개 (`meetingParticipants`)

---

## 엔티티 매핑 예시

### `User.java`

```java
@OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
private List<MeetingParticipant> meetingParticipants = new ArrayList<>();
```

### `Meeting.java`

```java
@OneToMany(mappedBy = "meeting", cascade = CascadeType.ALL, orphanRemoval = true)
private List<MeetingParticipant> meetingParticipants = new ArrayList<>();
```

### `MeetingParticipant.java`

```java
@ManyToOne
@JoinColumn(name = "user_id")
private User user;

@ManyToOne
@JoinColumn(name = "meeting_id")
private Meeting meeting;
```

---

## 이렇게 하면 좋은 점

1. **N\:M 관계를 명확하게 풀어낸 구조**라서 JPA 매핑이 단순해집니다.
2. 중간 엔티티(`MeetingParticipant`)에

    * 참가 상태(대기, 승인, 거절)
    * 참가 신청일
    * 권한(호스트/참가자)
      같은 **추가 컬럼**을 쉽게 넣을 수 있습니다.

---

PR 작성, feat: #18 모임 관련 Entity, Repository 수정

```text
User, MeetingParticipant, Meeting의 연관관계를 아래와 같이 정의함.

User : MeetingParticipant = 1 : N
Meeting : MeetingParticipant = 1 : N
User : Meeting = 1 : N
User와 Meeting은 중간 엔티티인 MeetingParticipant를 통해 M : N 관계를 가짐.
하지만 Meeting 엔티티의 방장 아이디(host_id)를 통해 1 : N의 연관관계를 갖기도 함.
```
